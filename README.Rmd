---
title: "fusedTree"
author: JM Goedhart
date: July 2, 2025
output:
  md_document:
    variant: gfm
---

```{r setup, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  fig.path = "man/figures/README-",
  out.width = "100%"
)
```

# fusedTree

**fusedTree** is a prediction model that integrates a set of low‑dimensional, established clinical variables with high‑dimensional, noisy omics variables. It fits (generalized) linear regression models in each leaf node of a tree, enabling both interpretability and flexibility in handling complex data structures.

- The tree is built using **clinical variables only**.
- The linear regression models within each leaf node use **omics variables only**.
- Leaf‑node‑specific regression models are estimated via penalized likelihood, combining:
  - A standard **ridge (L2) penalty**
  - A **fusion penalty**, linking the regression models across leaf nodes
  - unpenalized leaf-node-specific intercepts to account for the established
  signal in the clinical variables

**Note:** Tree construction must be done externally (e.g., with the [`rpart`](https://cran.r-project.org/package=rpart) package in R).

For full methodological details, see the [preprint](https://arxiv.org/abs/2411.02396).

---
  
## Installation
  
```{r installation, eval = FALSE}
# CRAN (when available)
install.packages("fusedTree")

# Development version from GitHub
remotes::install_github("JeroenGoedhart/fusedTree")
```

---
  
## Example 1: Continuous Outcomes
  
We illustrate the model for a continuous response. The simulated data has a nonlinear relationship with clinical variables and a linear relationship with omics variables.

```{r load-packages}
library(fusedTree)
if (!requireNamespace("rpart", quietly = TRUE)) install.packages("rpart")
library(rpart)
```

### 1. Simulate Data

```{r simulate-data}
set.seed(10)
p       <- 5       # Number of omics variables
p_Clin  <- 5       # Number of clinical variables
N       <- 100     # Sample size

# Nonlinear function of clinical variables
g <- function(z) {
  15 * sin(pi * z[,1] * z[,2]) +
    10 * (z[,3] - 0.5)^2 +
    2  * exp(z[,4]) +
    2  * z[,5]
}

# Clinical and omics covariates
Z      <- as.data.frame(matrix(runif(N * p_Clin), nrow = N))
X      <- matrix(rnorm(N * p), nrow = N)
betas  <- c(1, -1, 3, 2, -2)

# Response: nonlinear clinical + linear omics + noise
Y      <- as.vector(g(Z) + X %*% betas + rnorm(N))
```
Thus, the response is generated by a nonlinear clinical part and a separate linear
omics part. Therefore, the omics variables do not vary with the clinical variables.
The omics regressions in the different nodes of the tree should therefore benefit
from strong fusion.

### 2. Fit a Tree on Clinical Variables

```{r fit-tree}
dat    <- cbind.data.frame(Y, Z)
rp     <- rpart(
  Y ~ ., data = dat,
  control = rpart.control(xval = 5, minbucket = 10),
  model = TRUE
)
# poste-prune the tree
cp     <- rp$cptable[which.min(rp$cptable[, "xerror"]), "CP"]
Treefit <- prune(rp, cp = cp)

plot(Treefit, main = "Clinical-variable Tree")
text(Treefit, use.n = TRUE)
```

### 3. (Optional) Understanding the Design Matrices

Before fitting the model, it's useful to understand how **fusedTree** internally represents the data to enable leaf-specific regression. 
Each **leaf node** of the tree gets its own (generalized) linear regression model. To support this, two large design matrices are constructed: 

- **Clinical design matrix** (`Clinical`):  
  A binary intercept indicator matrix of size `N × (# of leaf nodes)`. Each column corresponds to a leaf node, with entries equal to 1 if an observation falls into that node and 0 otherwise.

- **Omics design matrix** (`Omics`):  
  A matrix of size `N × (p × # of leaf nodes)` where `p` is the number of omics variables. For each leaf node, the corresponding block of columns contains the omics values **only for the observations in that node**; entries are 0 elsewhere.

These matrices are created automatically during model fitting, but you can inspect them yourself using the `Dat_Tree()` function:

```{r inspect-design}
Dat_fusedTree <- Dat_Tree(Tree = Treefit, X = X, Z = Z, LinVars = FALSE)

# Clinical design matrix: indicator for node membership
head(Dat_fusedTree$Clinical)

# Omics design matrix: omics data distributed across nodes
head(Dat_fusedTree$Omics)
```


**Note:** You do not need to create these matrices manually — this step is handled internally by the `fusedTree()` function. However, visualizing them can help you better understand how the model applies fusion across leaf-specific regressions.

### 4. Tune Hyperparameters

Create balanced cross‑validation folds across the leaf nodes. Folds are balanced
w.r.t the proportion of observations in the leaf nodes, and w.r.t the outcome for
binary and survival data.
  
```{r tune-params}
set.seed(11)
folds <- CVfoldsTree(Y = Y, Tree = Treefit, Z = Z, model = "linear")

optPenalties <- PenOpt(
  Tree      = Treefit,
  X         = X,
  Y         = Y,
  Z         = Z,
  model     = "linear",
  lambdaInit = 10,
  alphaInit  = 10,
  loss      = "loglik",
  LinVars   = FALSE,
  folds     = folds,
  multistart = FALSE  # TRUE yields more stable but slower results
)

optPenalties
```

As seen, the fusion penalty alpha is tuned to a (very) large value as expected. 
The standard ridge penalty is (very) small because of the low-dimensional simulation setting

### 5. Fit fusedTree

```{r fit-fusedTree}
fit <- fusedTree(
  Tree    = Treefit,
  X       = X,
  Y       = Y,
  Z       = Z,
  LinVars = FALSE,
  model   = "linear",
  lambda  = optPenalties[1],
  alpha   = optPenalties[2]
)

# View results
fit$Effects     # Omics effects per leaf
plot(fit$Tree)  # Underlying tree structure
fit$Pars        # Model parameters
```

Because of the strong fusion penalty, the estimated omics effects across leaf nodes are (nearly) identical.
However, some bias remains in the omics effect estimates due to the tree’s limited ability to capture the nonlinear structure in the clinical variables. Since the leaf-node-specific intercepts (representing the clinical contribution) and the omics effects are estimated jointly, bias in the intercepts propagates into the omics coefficients.


### 6. Predict on New Data

```{r predict-test}
# Simulate test set
N_test <- 50
Z_test <- as.data.frame(matrix(runif(N_test * p_Clin), nrow = N_test))
X_test <- matrix(rnorm(N_test * p), nrow = N_test)
Y_test <- as.vector(g(Z_test) + X_test %*% betas + rnorm(N_test))

# Generate predictions
Preds <- predict(fit, newX = X_test, newY = Y_test, newZ = Z_test)
PMSE  <- mean((Preds$Resp - Preds$Ypred)^2)
PMSE
```

## Example 2: Binary Outcome

Below is a short example showing how to use `fusedTree` for binary outcomes. We simulate a binary response using a logistic model, with omics effects shared across leaf nodes.

```{r binary-example, message = FALSE}
# Load package
library(fusedTree)
if (!requireNamespace("rpart", quietly = TRUE)) install.packages("rpart")

# Settings
set.seed(13)
N <- 300
p <- 5
p_Clin <- 5

# Simulate data
Z <- as.data.frame(matrix(runif(N * p_Clin), nrow = N))  # clinical variables
X <- matrix(rnorm(N * p), nrow = N)                      # omics variables
betas  <- c(1, -1, 3, 2, -2)
eta <- 15 * sin(pi * Z[,1] * Z[,2]) - 10 * (Z[,3] - 0.5)^2 -
       2 * exp(Z[,4]) - 2 * Z[,5] + X %*% betas
prob <- 1 / (1 + exp(-eta))
Y <- rbinom(N, size = 1, prob = prob)

# Fit tree using only clinical variables
dat <- data.frame(Y = Y, Z)
rp <- rpart::rpart(Y ~ ., data = dat,
                   control = rpart::rpart.control(xval = 10, minbucket = 10),
                   method = "class", model = TRUE)
cp <- rp$cptable[,1][which.min(rp$cptable[,4])]
Treefit <- rpart::prune(rp, cp = cp)
plot(Treefit)
```

We then tune the penalties and fit the fusedTree model:

```{r binary-tune}
# Create folds
set.seed(30)
folds <- CVfoldsTree(Y = Y, Tree = Treefit, Z = Z, 
                     model = "logistic", nrepeat = 1)

# Tune hyperparameters
optPenalties <- PenOpt(Tree = Treefit, X = X, Y = Y, Z = Z,
                       model = "logistic",
                       lambdaInit = 10, alphaInit = 10,
                       loss = "loglik",
                       LinVars = FALSE,
                       folds = folds,
                       multistart = TRUE) # slower
optPenalties

# Fit fusedTree
fit_bin <- fusedTree(Tree = Treefit, X = X, Y = Y, Z = Z,
                     LinVars = FALSE, model = "logistic",
                     lambda = optPenalties[1],
                     alpha = optPenalties[2],
                     verbose = TRUE) # prints progress of IRLS algorithm
fit_bin$Effects
```

Finally, we simulate test data and evaluate classification performance:

```{r binary-predict}
# Simulate test data
N_test <- 50
Z_test <- as.data.frame(matrix(runif(N_test * p_Clin), nrow = N_test))
X_test <- matrix(rnorm(N_test * p), nrow = N_test)
eta_test <- 15 * sin(pi * Z_test[,1] * Z_test[,2]) - 10 * (Z_test[,3] - 0.5)^2 -
            2 * exp(Z_test[,4]) - 2 * Z_test[,5] + X_test %*% betas
prob_test <- 1 / (1 + exp(-eta_test))
Y_test <- rbinom(N_test, size = 1, prob = prob_test)

# Predict
Preds <- predict(fit_bin, newX = X_test, newY = Y_test, newZ = Z_test)

# AUC
if (!requireNamespace("pROC", quietly = TRUE)) install.packages("pROC")
library(pROC)
auc_result <- pROC::auc(Y_test, Preds$Ypred)
auc_result
```


This example demonstrates how to apply `fusedTree` to binary classification problems using logistic regression and prediction based on the estimated fused model.

  
## Summary
  
  **fusedTree** provides:
  
  - **Interpretability** via a tree on clinical variables  
- **High‑dimensional regression** on omics data within each leaf  
- **Information exchange** across leaves through a fusion penalty  

See the [paper](https://arxiv.org/abs/2411.02396) for applications to survival outcomes, and further methodological details.
